<!DOCTYPE html>
<html lang="ja">

<head>
    <meta charset="UTF-8">
    <title>WPF による開発覚え書き</title>
    <link rel="stylesheet" type="text/css" href="Style.css">
    <link rel="icon" type="image/png" href="Icon.png">
    <link rel="start" href="index.html" title="トップページ">
    <meta name="author" content="Itaru">
    <style>
        .keyword,
        .xamlsign {
            color: #0000FF
        }

        .comment {
            color: #008000
        }

        .usertype {
            color: #2B91AF
        }

        .string {
            color: #A31515
        }

        .xamlname {
            color: #A31515
        }

        .xamlattr {
            color: #FF0000
        }
    </style>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.13.1/styles/vs.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.13.1/highlight.min.js"></script>
    <script>hljs.initHighlightingOnLoad();</script>
</head>

<body>
    <header>
        <a href="/"><img src="Logo.svg" width="400" height="80" alt="トップページへ"></a>
        <dl>
            <dt>最終更新</dt>
            <dd>2018年12月2日 22時35分</dd>
        </dl>
    </header>
    <h1>WPF による開発覚え書き</h1>
    <p>Visual C# 2010 Express や、Visual Studio Community 2015、Visual Studio Community 2017 で、WPF
        アプリケーションを開発した際の覚え書きです。未だ WPF には詳しくないので、ここに書いてあることは大間違いかもしれません。</p>
    <ol>
        <li>
            Visual C# 2010 Express 時代
            <ul>
                <li><a href="#1">コマンドライン引数を取得する（<code>Startup</code>イベントを使う）</a></li>
                <li><a href="#2">二重起動を防止する（<code>Mutex</code>を使う）</a></li>
                <li><a href="#3">任意のコレクションオブジェクトの内容を<code>ListBox</code>や<code>ListView</code>で表示する</a></li>
                <li><a href="#4"><code>ListView</code>の各列に指定したプロパティを表示する</a></li>
                <li><a href="#5"><code>ListView</code>の各列の幅を自動的に最適にする</a></li>
                <li><a href="#6">アニメーションの開始/一時停止/再開/停止</a></li>
                <li><a href="#7"><code>ListBox</code>の項目のドラッグによる並べ替え</a></li>
            </ul>
        </li>
        <li>
            Visual Studio Community 2015 時代
            <ul>
                <li><a href="#8">コマンドライン引数を取得する（<code>Main</code>メソッドを使う）</a></li>
                <li><a href="#9">二重起動を防止する（<code>Semaphore</code>を使う）</a></li>
                <li><a href="#10">アプリケーション間の通信</a></li>
                <li><a href="#11">二重起動を防止し、起動中のウィンドウをアクティブにする</a></li>
                <li><a href="#12">二重起動を防止し、起動中のウィンドウをアクティブにしてコマンドライン引数を渡す</a></li>
            </ul>
        </li>
        <li>
            Visual Studio Community 2017 時代
            <ul>
                <li><a href="#13">二重起動を防止し、起動中のウィンドウをアクティブにする（メモリマップトファイルを使う）</a></li>
            </ul>
        </li>
    </ol>
    <section>
        <h2 id="1">コマンドライン引数を取得する（<code>Startup</code>イベントを使う）</h2>
        <p>Visual C# 2010 Express で WPF アプリケーション プロジェクトを作成すると、App.xaml、App.xaml.cs、MainWindow.xaml、MainWindow.xaml.cs
            の4つのファイルが生成されます。このうちの App.xaml
            の<code>Application</code>要素から<code>StartupUri</code>属性を削除し、<code>Startup</code>属性にイベントハンドラーとなるメソッドの名前を指定します。
        </p>
        <pre><code><span class="xamlsign">&lt;</span><span class="xamlname">Application</span> <span class="xamlattr">x</span>:<span class="xamlattr">Class</span><span class="xamlsign">="WpfApplication1.App"</span>
             <span class="xamlattr">xmlns</span><span class="xamlsign">="http://schemas.microsoft.com/winfx/2006/xaml/presentation"</span>
             <span class="xamlattr">xmlns</span><span class="xamlsign">:</span><span class="xamlattr">x</span><span class="xamlsign">="http://schemas.microsoft.com/winfx/2006/xaml"</span>
             <span class="xamlattr">Startup</span><span class="xamlsign">="Application_Startup"&gt;</span>
    <span class="xamlsign">&lt;</span><span class="xamlname">Application.Resources</span><span class="xamlsign">&gt;</span>

    <span class="xamlsign">&lt;/</span><span class="xamlname">Application.Resources</span><span class="xamlsign">&gt;</span>
<span class="xamlsign">&lt;/</span><span class="xamlname">Application</span><span class="xamlsign">&gt;</span></code></pre>
        <p>App.xaml.csは次のようにします。イベントハンドラーに渡される<code>StartupEventArgs</code>オブジェクトの<code>Args</code>プロパティーがコマンドライン引数です。
        </p>
        <pre><code><span class="keyword">using</span> System.Windows;

<span class="keyword">namespace</span> WpfApplication1
{
    <span class="keyword">public</span> <span class="keyword">partial</span> <span class="keyword">class</span> <span class="usertype">App</span> : <span class="usertype">Application</span>
    {
        <span class="keyword">private</span> <span class="keyword">void</span> Application_Startup(<span class="keyword">object</span> sender, <span class="usertype">StartupEventArgs</span> e)
        {
            <span class="keyword">foreach</span> (<span class="keyword">string</span> arg <span class="keyword">in</span> e.Args)
                <span class="usertype">MessageBox</span>.Show(arg);

            <span class="comment">// ウィンドウを表示。</span>
            <span class="usertype">MainWindow</span> mainWindow = <span class="keyword">new</span> <span class="usertype">MainWindow</span>(); <span class="comment">// 13行目</span>
            mainWindow.Show();                        <span class="comment">// 14行目</span>
        }
    }
}</code></pre>
        <p>App.xamlから<code>StartupUri</code>属性を削除したので、13、14行目を書かないとウィンドウは表示されません。</p>
    </section>
    <section>
        <h2 id="2">二重起動を防止する（<code>Mutex</code>を使う）</h2>
        <p><code>System.Threading.Mutex</code>を使います。<code>Mutex</code>のコンストラクターで、UUIDなど、アプリケーションを一意に識別するための文字列を渡します。</p>
        <pre><code><span class="keyword">using</span> System.Threading;
<span class="keyword">using</span> System.Windows;

<span class="keyword">namespace</span> WpfApplication1
{
    <span class="keyword">public</span> <span class="keyword">partial</span> <span class="keyword">class</span> <span class="usertype">App</span> : <span class="usertype">Application</span>
    {
        <span class="keyword">private</span> <span class="keyword">static</span> <span class="usertype">Mutex</span> mutex = <span class="keyword">new</span> <span class="usertype">Mutex</span>(<span class="keyword">false</span>, <span class="string">"WpfApplication1"</span>); <span class="comment">// 実際はUUIDなどがよい。</span>

        <span class="keyword">private</span> <span class="keyword">void</span> Application_Startup(<span class="keyword">object</span> sender, <span class="usertype">StartupEventArgs</span> e)
        {
            <span class="keyword">if</span> (mutex.WaitOne(0, <span class="keyword">false</span>))
            {
                <span class="usertype">MessageBox</span>.Show(<span class="string">"先に起動しているインスタンスはありません。"</span>);

                <span class="comment">// ウィンドウを表示</span>
                <span class="usertype">MainWindow</span> mainWindow = <span class="keyword">new</span> <span class="usertype">MainWindow</span>();
                mainWindow.Show();
            }
            <span class="keyword">else</span>
            {
                <span class="usertype">MessageBox</span>.Show(<span class="string">"先に起動しているインスタンスがあります。"</span>);
                Shutdown(); <span class="comment">// 終了する。</span>
            }
        }
    }
}</code></pre>
        <p>注意点として、生成した<code>Mutex</code>オブジェクトがガーベッジコレクションによって消滅すると、2つ目以降のインスタンスが起動できるようになってしまいます。そこで上記の例では、<code>Mutex</code>オブジェクトをstaticフィールドとすることで、消滅しないようにしています。
        </p>
    </section>
    <section>
        <h2 id="3">任意のコレクションオブジェクトの内容を<code>ListBox</code>や<code>ListView</code>で表示する</h2>
        <p>次のように、<code>ListBox</code>や<code>ListView</code>の<code>ItemsSource</code>プロパティーにコレクションオブジェクトを指定するだけです。コレクションオブジェクトは、<code>System.Collections.IEnumerable</code>を実装している必要があります。
        </p>
        <pre><code><span class="keyword">using</span> System.Collections.Generic;
<span class="keyword">using</span> System.ComponentModel;
<span class="keyword">using</span> System.Windows;
<span class="keyword">using</span> System.Windows.Data;

<span class="keyword">namespace</span> WpfApplication1
{
    <span class="keyword">public</span> <span class="keyword">partial</span> <span class="keyword">class</span> <span class="usertype">App</span> : <span class="usertype">Application</span>
    {
        <span class="usertype">List</span>&lt;<span class="keyword">string</span>&gt; list = <span class="keyword">new</span> <span class="usertype">List</span>&lt;<span class="keyword">string</span>&gt;();
        <span class="usertype">ICollectionView</span> collectionView;

        <span class="keyword">private</span> <span class="keyword">void</span> Application_Startup(<span class="keyword">object</span> sender, <span class="usertype">StartupEventArgs</span> e)
        {
            list.Add(<span class="string">"リートルード"</span>);
            list.Add(<span class="string">"Hello, World!"</span>);
            collectionView = <span class="usertype">CollectionViewSource</span>.GetDefaultView(list);

            <span class="usertype">MainWindow</span> mainWindow = <span class="keyword">new</span> <span class="usertype">MainWindow</span>();

            mainWindow.listBox1.ItemsSource = list;

            mainWindow.Show();

            list.Add(<span class="string">"Coming Era..."</span>);
            collectionView.Refresh(); <span class="comment">// 26行目</span>
        }
    }
}</code></pre>
        <p>ただし、コレクションオブジェクトの更新を<code>ListBox</code>や<code>ListView</code>の表示に反映させるには、26行目のように<code>ICollectionView.Refresh</code>メソッドを呼び出す必要があります。あるいは、ObservableCollectionクラスを使えば、Refresh()は不要です。
        </p>
    </section>
    <section>
        <h2 id="4"><code>ListView</code>の各列に指定したプロパティを表示する</h2>
        <p>次のように、<code>GridViewColumn</code>要素の<code>DisplayMemberBinding</code>属性で、プロパティ名を指定します。</p>
        <pre><code><span class="xamlsign">&lt;</span><span class="xamlname">Window</span> <span class="xamlattr">x</span><span class="xamlsign">:</span><span class="xamlattr">Class</span><span class="xamlsign">="WpfApplication1.MainWindow"</span>
        <span class="xamlattr">xmlns</span><span class="xamlsign">="http://schemas.microsoft.com/winfx/2006/xaml/presentation"</span>
        <span class="xamlattr">xmlns</span><span class="xamlsign">:</span><span class="xamlattr">x</span><span class="xamlsign">="http://schemas.microsoft.com/winfx/2006/xaml"</span>
        <span class="xamlattr">Title</span><span class="xamlsign">="MainWindow"</span> <span class="xamlattr">Width</span><span class="xamlsign">="400"</span> <span class="xamlattr">Height</span><span class="xamlsign">="300"&gt;</span>
    <span class="xamlsign">&lt;</span><span class="xamlname">Grid</span><span class="xamlsign">&gt;</span>
        <span class="xamlsign">&lt;</span><span class="xamlname">ListView</span> <span class="xamlattr">Name</span><span class="xamlsign">="listView1"&gt;</span>
            <span class="xamlsign">&lt;</span><span class="xamlname">ListView.View</span><span class="xamlsign">&gt;</span>
                <span class="xamlsign">&lt;</span><span class="xamlname">GridView</span><span class="xamlsign">&gt;</span>
                    <span class="xamlsign">&lt;</span><span class="xamlname">GridViewColumn</span> <span class="xamlattr">DisplayMemberBinding</span><span class="xamlsign">="{</span><span class="xamlname">Binding</span> <span class="xamlattr">Name</span><span class="xamlsign">}"/&gt;</span>
                    <span class="xamlsign">&lt;</span><span class="xamlname">GridViewColumn</span> <span class="xamlattr">DisplayMemberBinding</span><span class="xamlsign">="{</span><span class="xamlname">Binding</span> <span class="xamlattr">Level</span><span class="xamlsign">}"/&gt;</span>
                <span class="xamlsign">&lt;/</span><span class="xamlname">GridView</span><span class="xamlsign">&gt;</span>
            <span class="xamlsign">&lt;/</span><span class="xamlname">ListView.View</span><span class="xamlsign">&gt;</span>
        <span class="xamlsign">&lt;/</span><span class="xamlname">ListView</span><span class="xamlsign">&gt;</span>
    <span class="xamlsign">&lt;/</span><span class="xamlname">Grid</span><span class="xamlsign">&gt;</span>
<span class="xamlsign">&lt;/</span><span class="xamlname">Window</span><span class="xamlsign">&gt;</span></code></pre>
        <p>この例では、App.xaml.csは次のようにしています。<code>User</code>というクラスがあり、<code>ListView</code>の各行に表示されるのは、<code>List</code>に格納された<code>User</code>のインスタンスです。
        </p>
        <pre><code><span class="keyword">using</span> System.Collections.Generic;
<span class="keyword">using</span> System.ComponentModel;
<span class="keyword">using</span> System.Windows;
<span class="keyword">using</span> System.Windows.Data;

<span class="keyword">namespace</span> WpfApplication1
{
    <span class="keyword">public</span> <span class="keyword">partial</span> <span class="keyword">class</span> <span class="usertype">App</span> : <span class="usertype">Application</span>
    {
        <span class="usertype">List</span>&lt;<span class="usertype">User</span>&gt; list = <span class="keyword">new</span> <span class="usertype">List</span>&lt;<span class="usertype">User</span>&gt;();
        <span class="usertype">ICollectionView</span> collectionView;

        <span class="keyword">private</span> <span class="keyword">void</span> Application_Startup(<span class="keyword">object</span> sender, <span class="usertype">StartupEventArgs</span> e)
        {
            list.Add(<span class="keyword">new</span> <span class="usertype">User</span>(<span class="string">"Abc"</span>, 5));
            list.Add(<span class="keyword">new</span> <span class="usertype">User</span>(<span class="string">"Defg"</span>, 4));
            collectionView = <span class="usertype">CollectionViewSource</span>.GetDefaultView(list);

            <span class="usertype">MainWindow</span> mainWindow = <span class="keyword">new</span> <span class="usertype">MainWindow</span>();

            mainWindow.listView1.ItemsSource = list;

            mainWindow.Show();

            list.Add(<span class="keyword">new</span> <span class="usertype">User</span>(<span class="string">"Hijkl"</span>, 7));
            collectionView.Refresh();
        }
    }

    <span class="keyword">class</span> <span class="usertype">User</span>
    {
        <span class="keyword">public</span> <span class="keyword">string</span> Name { <span class="keyword">get</span>; <span class="keyword">set</span>; }
        <span class="keyword">public</span> <span class="keyword">int</span> Level { <span class="keyword">get</span>; <span class="keyword">set</span>; }

        <span class="keyword">public</span> User(<span class="keyword">string</span> name, <span class="keyword">int</span> level)
        {
            Name = name;
            Level = level;
        }
    }
}</code></pre>
    </section>
    <section>
        <h2 id="5"><code>ListView</code>の各列の幅を自動的に最適にする</h2>
        <pre><code><span class="keyword">foreach</span> (<span class="usertype">GridViewColumn</span> column <span class="keyword">in</span> (listView1.View <span class="keyword">as</span> <span class="usertype">GridView</span>).Columns)
{
    column.Width = 0;
    column.Width = <span class="keyword">double</span>.NaN;
}</code></pre>
        <p>このようにすれば、列ヘッダーの境界をダブルクリックしたときのように、列幅が最適な状態になります。何度も行うなら、その<code>GridViewColumn</code>をフィールドに保持しておいてもいいでしょう。
        </p>
    </section>
    <section>
        <h2 id="6">アニメーションの開始/一時停止/再開/停止</h2>
        <p>次のようなXAMLがあるとします。</p>
        <pre><code><span class="xamlsign">&lt;</span><span class="xamlname">Window</span> <span class="xamlattr">x</span><span class="xamlsign">:</span><span class="xamlattr">Class</span><span class="xamlsign">="WpfApplication1.MainWindow"</span>
         <span class="xamlattr">xmlns</span><span class="xamlsign">="http://schemas.microsoft.com/winfx/2006/xaml/presentation"</span>
         <span class="xamlattr">xmlns</span><span class="xamlsign">:</span><span class="xamlattr">x</span><span class="xamlsign">="http://schemas.microsoft.com/winfx/2006/xaml"</span>
         <span class="xamlattr">Title</span><span class="xamlsign">="MainWindow"</span> <span class="xamlattr">Width</span><span class="xamlsign">="400"</span> <span class="xamlattr">Height</span><span class="xamlsign">="300"&gt;</span>
     <span class="xamlsign">&lt;</span><span class="xamlname">StackPanel</span><span class="xamlsign">&gt;</span>
         <span class="xamlsign">&lt;</span><span class="xamlname">Rectangle</span> <span class="xamlattr">Name</span><span class="xamlsign">="rectangle1"</span> <span class="xamlattr">Width</span><span class="xamlsign">="0"</span> <span class="xamlattr">Height</span><span class="xamlsign">="20"</span> <span class="xamlattr">Fill</span><span class="xamlsign">="Blue"/&gt;</span>
         <span class="xamlsign">&lt;</span><span class="xamlname">Button</span> <span class="xamlattr">Content</span><span class="xamlsign">="Start"</span> <span class="xamlattr">Click</span><span class="xamlsign">="StartButton_Click"/&gt;</span>
         <span class="xamlsign">&lt;</span><span class="xamlname">Button</span> <span class="xamlattr">Content</span><span class="xamlsign">="Pause/Resume"</span> <span class="xamlattr">Click</span><span class="xamlsign">="PauseResumeButton_Click"</span> <span class="xamlattr">IsEnabled</span><span class="xamlsign">="False"</span> <span class="xamlattr">Name</span><span class="xamlsign">="pauseResumeButton"/&gt;</span>
         <span class="xamlsign">&lt;</span><span class="xamlname">Button</span> <span class="xamlattr">Content</span><span class="xamlsign">="Stop"</span> <span class="xamlattr">Click</span><span class="xamlsign">="StopButton_Click"</span> <span class="xamlattr">IsEnabled</span><span class="xamlsign">="False"</span> <span class="xamlattr">Name</span><span class="xamlsign">="stopButton"/&gt;</span>
         <span class="comment">&lt;!-- 起動直後はPause/ResumeボタンとStopボタンは無効状態としている。--&gt;</span>
     <span class="xamlsign">&lt;/</span><span class="xamlname">StackPanel</span><span class="xamlsign">&gt;</span>
 <span class="xamlsign">&lt;/</span><span class="xamlname">Window</span><span class="xamlsign">&gt;</span></code></pre>
        <p>Startボタンを押すとアニメーション開始、Pause/Resumeボタンを押すと一時停止、同じボタンをもう一度押すと再開、Stopボタンを押すと停止、という挙動をC#コードで実現するには、MainWindow.xaml.csを次のようにします。
        </p>
        <pre><code><span class="keyword">using</span> System;
<span class="keyword">using</span> System.Windows;
<span class="keyword">using</span> System.Windows.Media.Animation;
<span class="keyword">using</span> System.Windows.Shapes;

<span class="keyword">namespace</span> WpfApplication1
{
    <span class="keyword">public</span> <span class="keyword">partial</span> <span class="keyword">class</span> <span class="usertype">MainWindow</span> : <span class="usertype">Window</span>
    {
        <span class="usertype">Storyboard</span> storyboard = <span class="keyword">new</span> <span class="usertype">Storyboard</span>();

        <span class="keyword">public</span> MainWindow()
        {
            InitializeComponent();

            <span class="usertype">DoubleAnimation</span> animation = <span class="keyword">new</span> <span class="usertype">DoubleAnimation</span>();

            <span class="usertype">Storyboard</span>.SetTarget(animation, rectangle1);
            <span class="usertype">Storyboard</span>.SetTargetProperty(animation, <span class="keyword">new</span> <span class="usertype">PropertyPath</span>(<span class="usertype">Rectangle</span>.WidthProperty));
            animation.To = 400; <span class="comment">// アニメーション後の値を指定。</span>
            animation.Duration = <span class="usertype">TimeSpan</span>.FromSeconds(10); <span class="comment">// アニメーションする時間を指定。</span>
            storyboard.Children.Add(animation);
        }

        <span class="keyword">private</span> <span class="keyword">void</span> StartButton_Click(<span class="keyword">object</span> sender, <span class="usertype">RoutedEventArgs</span> e)
        {
            storyboard.Begin();

            <span class="keyword">if</span> (!pauseResumeButton.IsEnabled)
            {
                <span class="comment">// 起動直後は無効状態としていたPause/ResumeボタンとStopボタンを有効にする。</span>
                pauseResumeButton.IsEnabled = <span class="keyword">true</span>;
                stopButton.IsEnabled = <span class="keyword">true</span>;
            }
        }

        <span class="keyword">private</span> <span class="keyword">void</span> PauseResumeButton_Click(<span class="keyword">object</span> sender, <span class="usertype">RoutedEventArgs</span> e)
        {
            <span class="keyword">if</span> (storyboard.GetIsPaused())
                storyboard.Resume();
            <span class="keyword">else</span>
                storyboard.Pause();
        }

        <span class="keyword">private</span> <span class="keyword">void</span> StopButton_Click(<span class="keyword">object</span> sender, <span class="usertype">RoutedEventArgs</span> e)
        {
            storyboard.Stop();
        }
    }
}</code></pre>
    </section>
    <section>
        <h2 id="7"><code>ListBox</code>の項目のドラッグによる並べ替え</h2>
        <p>MainWindow.xamlは次のようにします。</p>
        <pre><code><span class="xamlsign">&lt;</span><span class="xamlname">Window</span> <span class="xamlattr">x</span><span class="xamlsign">:</span><span class="xamlattr">Class</span><span class="xamlsign">="ListBoxExTest.MainWindow"</span>
         <span class="xamlattr">xmlns</span><span class="xamlsign">="http://schemas.microsoft.com/winfx/2006/xaml/presentation"</span>
         <span class="xamlattr">xmlns</span><span class="xamlsign">:</span><span class="xamlattr">x</span><span class="xamlsign">="http://schemas.microsoft.com/winfx/2006/xaml"</span>
         <span class="xamlattr">Title</span><span class="xamlsign">="MainWindow"</span> <span class="xamlattr">Height</span><span class="xamlsign">="350"</span> <span class="xamlattr">Width</span><span class="xamlsign">="525"&gt;</span>
     <span class="xamlsign">&lt;</span><span class="xamlname">Grid</span><span class="xamlsign">&gt;</span>
         <span class="xamlsign">&lt;</span><span class="xamlname">ListBox</span> <span class="xamlattr">Name</span><span class="xamlsign">="listBox1"&gt;</span>
             <span class="xamlsign">&lt;</span><span class="xamlname">ListBoxItem</span> <span class="xamlattr">AllowDrop</span><span class="xamlsign">="True"</span> <span class="xamlattr">MouseMove</span><span class="xamlsign">="ListBoxItem_MouseMove"</span> <span class="xamlattr">DragEnter</span><span class="xamlsign">="ListBoxItem_DragEnter"&gt;</span><span class="xamlname">色は匂えど</span><span class="xamlsign">&lt;/</span><span class="xamlname">ListBoxItem</span><span class="xamlsign">&gt;</span>
             <span class="xamlsign">&lt;</span><span class="xamlname">ListBoxItem</span> <span class="xamlattr">AllowDrop</span><span class="xamlsign">="True"</span> <span class="xamlattr">MouseMove</span><span class="xamlsign">="ListBoxItem_MouseMove"</span> <span class="xamlattr">DragEnter</span><span class="xamlsign">="ListBoxItem_DragEnter"&gt;</span><span class="xamlname">散りぬるを</span><span class="xamlsign">&lt;/</span><span class="xamlname">ListBoxItem</span><span class="xamlsign">&gt;</span>
             <span class="xamlsign">&lt;</span><span class="xamlname">ListBoxItem</span> <span class="xamlattr">AllowDrop</span><span class="xamlsign">="True"</span> <span class="xamlattr">MouseMove</span><span class="xamlsign">="ListBoxItem_MouseMove"</span> <span class="xamlattr">DragEnter</span><span class="xamlsign">="ListBoxItem_DragEnter"&gt;</span><span class="xamlname">我が世誰ぞ</span><span class="xamlsign">&lt;/</span><span class="xamlname">ListBoxItem</span><span class="xamlsign">&gt;</span>
             <span class="xamlsign">&lt;</span><span class="xamlname">ListBoxItem</span> <span class="xamlattr">AllowDrop</span><span class="xamlsign">="True"</span> <span class="xamlattr">MouseMove</span><span class="xamlsign">="ListBoxItem_MouseMove"</span> <span class="xamlattr">DragEnter</span><span class="xamlsign">="ListBoxItem_DragEnter"&gt;</span><span class="xamlname">常ならん</span><span class="xamlsign">&lt;/</span><span class="xamlname">ListBoxItem</span><span class="xamlsign">&gt;</span>
         <span class="xamlsign">&lt;/</span><span class="xamlname">ListBox</span><span class="xamlsign">&gt;</span>
     <span class="xamlsign">&lt;/</span><span class="xamlname">Grid</span><span class="xamlsign">&gt;</span>
 <span class="xamlsign">&lt;/</span><span class="xamlname">Window</span><span class="xamlsign">&gt;</span></code></pre>
        <p>まず<code>ListBoxItem</code>の<code>AllowDrop</code>プロパティをOnにします。そして、<code>MouseMove</code>と<code>DragEnter</code>という2つのイベントにイベントハンドラーを指定します。
        </p>
        <p>MainWindow.xaml.csは次のようにします。</p>
        <pre><code><span class="keyword">using</span> System.Windows;
<span class="keyword">using</span> System.Windows.Controls;
<span class="keyword">using</span> System.Windows.Input;

<span class="keyword">namespace</span> ListBoxExTest
{
    <span class="keyword">public</span> <span class="keyword">partial</span> <span class="keyword">class</span> <span class="usertype">MainWindow</span> : <span class="usertype">Window</span>
    {
        <span class="keyword">public</span> MainWindow()
        {
            InitializeComponent();
        }

        <span class="keyword">private</span> <span class="keyword">void</span> ListBoxItem_MouseMove(<span class="keyword">object</span> sender, <span class="usertype">MouseEventArgs</span> e)
        {
            <span class="keyword">if</span> (e.LeftButton == <span class="usertype">MouseButtonState</span>.Pressed)
                <span class="usertype">DragDrop</span>.DoDragDrop(sender <span class="keyword">as</span> <span class="usertype">ListBoxItem</span>, sender, <span class="usertype">DragDropEffects</span>.Move);
        }

        <span class="keyword">private</span> <span class="keyword">void</span> ListBoxItem_DragEnter(<span class="keyword">object</span> sender, <span class="usertype">DragEventArgs</span> e)
        {
            <span class="usertype">ListBoxItem</span> source = e.Data.GetData(<span class="keyword">typeof</span>(<span class="usertype">ListBoxItem</span>)) <span class="keyword">as</span> <span class="usertype">ListBoxItem</span>;

            <span class="usertype">ItemCollection</span> items = listBox1.Items;

            <span class="keyword">int</span> index = items.IndexOf(sender <span class="keyword">as</span> <span class="usertype">ListBoxItem</span>);
            items.Remove(source);
            items.Insert(index, source);
        }
    }
}</code></pre>
        <p>ドラッグの開始は、<code>MouseMove</code>のイベントハンドラーの中で、<code>DragDrop</code>クラスの静的メソッドである<code>DoDragDrop()</code>によって行います。このとき、並べ替える<code>ListBoxItem</code>を引数に指定しておきます。
        </p>
        <p>並べ替えは、<code>DragEnter</code>のイベントハンドラーの中で行います。第2引数の<code>DragEventArgs</code>オブジェクトの<code>Data</code>プロパティーの<code>GetData</code>メソッドで、先に指定した<code>ListBoxItem</code>が取得できます。
        </p>
    </section>
    <section>
        <h2 id="8">コマンドライン引数を取得する（<code>Main</code>メソッドを使う）</h2>
        <p>Visual Studio Community 2015でWPF アプリケーション
            プロジェクトを作成すると、App.xaml、App.xaml.cs、MainWindow.xaml、MainWindow.xaml.csの4つのファイルが生成されます。このうち、App.xamlのプロパティで、ビルド
            アクションをApplicationDefinitionからPageに変更します。</p>
        <p>ビルド
            アクションをPageにすると、<code>Main</code>メソッドが自動で実装されなくなり、以下のようにApp.xaml.csに明示的に定義する必要があります。このとき、<code>Main</code>メソッドの仮引数からコマンドライン引数を取得できます。
        </p>
        <pre><code><span class="keyword">using</span> System;
<span class="keyword">using</span> System.Windows;

<span class="keyword">namespace</span> WpfApplication1
{
    <span class="keyword">public</span> <span class="keyword">partial</span> <span class="keyword">class</span> <span class="usertype">App</span> : <span class="usertype">Application</span>
    {
        <em><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">string</span>[] Args { <span class="keyword">get</span>; <span class="keyword">set</span>; }</em>

        [<span class="usertype">STAThread</span>]
        <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> Main(<em><span class="keyword">string</span>[] args</em>)
        {
            <em>Args = args;</em>

            <span class="keyword">var</span> app = <span class="keyword">new</span> <span class="usertype">App</span>();       <span class="comment">// 15行目</span>
            app.InitializeComponent(); <span class="comment">// 16行目</span>
            app.Run();                 <span class="comment">// 17行目</span>
        }
    }
}</code></pre>
        <p>このコードでは、コマンドライン引数をほかの場所からも参照できるようにするため、<code>App</code>に<code>Args</code>という静的プロパティを定義し、そこに代入しています。また、<code>Main</code>メソッドを明示的に実装しているため、15～17行目を記述しなければアプリケーションは開始しません。
        </p>
        <dl>
            <dt>参考</dt>
            <dd><a href="http://www.atmarkit.co.jp/ait/articles/1511/04/news027.html">WPF：Mainメソッドを書き変えるには？［C#／VB］</a>
            </dd>
        </dl>
    </section>
    <section>
        <h2 id="9">二重起動を防止する（<code>Semaphore</code>を使う）</h2>
        <p><code>System.Threading.Semaphore</code>を使う方法です。<code>Semaphore</code>のコンストラクターで、UUIDなど、アプリケーションを一意に識別するための文字列を渡します。
        </p>
        <pre><code><span class="keyword">using</span> System;
<span class="keyword">using</span> System.Threading;
<span class="keyword">using</span> System.Windows;

<span class="keyword">namespace</span> WpfApplication1
{
    <span class="keyword">public</span> <span class="keyword">partial</span> <span class="keyword">class</span> <span class="usertype">App</span> : <span class="usertype">Application</span>
    {
        <em><span class="keyword">const</span> <span class="keyword">string</span> ApplicationId = <span class="string">&quot;00000000-0000-0000-0000-000000000000&quot;</span>;</em> <span class="comment">// 実際はUUIDなどが良い。</span>

        [<span class="usertype">STAThread</span>]
        <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> Main(<span class="keyword">string</span>[] args)
        {
            <em><span class="keyword">bool</span> createdNew;
            <span class="keyword">using</span> (<span class="keyword">var</span> semaphore = <span class="keyword">new</span> <span class="usertype">Semaphore</span>(1, 1, ApplicationId, <span class="keyword">out</span> createdNew))
            {
                <span class="keyword">if</span> (createdNew)
                {</em>
                    <span class="keyword">var</span> app = <span class="keyword">new</span> <span class="usertype">App</span>();
                    app.InitializeComponent();
                    app.Run();
                <em>}
            }</em>
        }
    }
}</code></pre>
        <dl>
            <dt>参考</dt>
            <dd><a href="http://www.atmarkit.co.jp/ait/articles/1511/18/news028.html">WPF：多重起動を禁止するには？［C#／VB］</a></dd>
        </dl>
    </section>
    <section>
        <h2 id="10">アプリケーション間の通信</h2>
        <p>まず、参照設定にSystem.Runtime.Remotingを追加する必要があります。</p>
        <p>次に、<code>System.MarshalByRefObject</code>を継承したクラスを作成します。</p>
        <pre><code><span class="keyword">using</span> System;
 
 <span class="keyword">namespace</span> WpfApplication1
 {
     <span class="keyword">class</span> <span class="usertype">Handler</span> : <span class="usertype">MarshalByRefObject</span>
     {
         <span class="keyword">public</span> <span class="keyword">void</span> Handle()
         {
             <span class="comment">// 通信が行われたときの処理を記述する。</span>
         }
 
         <span class="comment">// 通信可能な状態を保ち続けるためのオーバーライド。</span>
         <span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">object</span> InitializeLifetimeService() => <span class="keyword">null</span>;
     }
 }</code></pre>
        <p><code>MarshalByRefObject</code>を継承した<code>メッセージ</code>クラスでは、<code>InitializeLifetimeService</code>というメソッドをオーバーライドしています。これは、時間経過によって、通信できなくなる状態に自動的になってしまうのを防ぐためです。
        </p>
        <p>通信のサーバー側は、次のように記述します。<code>IpcServerChannel</code>のコンストラクターでは、UUIDなど、アプリケーションを一意に識別するための文字列を渡します。<code>RemotingServices.Marshal</code>メソッドの第2引数では、<code>MarshalByRefObject</code>オブジェクトを識別するための文字列を指定します。
        </p>
        <pre><code><span class="keyword">const</span> <span class="keyword">string</span> ApplicationId = <span class="string">"00000000-0000-0000-0000-000000000000"</span>; <span class="comment">// 実際はUUIDなどが良い。</span>
<span class="keyword">const</span> <span class="keyword">string</span> HandlerName = <span class="string">"handler"</span>;

<span class="usertype">ChannelServices</span>.RegisterChannel(<span class="keyword">new</span><span class="usertype">IpcServerChannel</span>(ApplicationId), <span class="keyword">true</span>);
<span class="usertype">RemotingServices</span>.Marshal(<span class="keyword">new</span> <span class="usertype">Handler</span>(), HandlerName, <span class="keyword">typeof</span>(<span class="usertype">Handler</span>));</code></pre>
        <p>通信のクライアント側は、次のように記述します。</p>
        <pre><code><span class="usertype">ChannelServices</span>.RegisterChannel(<span class="keyword">new</span> <span class="usertype">IpcClientChannel</span>(), <span class="keyword">true</span>);
((<span class="usertype">Handler</span>)<span class="usertype">Activator</span>.GetObject(<span class="keyword">typeof</span>(<span class="usertype">Handler</span>), <span class="string">"ipc://"</span> + ApplicationId + <span class="string">"/"</span> + HandlerName)).Handle();</code></pre>
        <p>ただし、ユーザーインターフェースに変更を加えるなど、別のスレッドに関係する処理を行う場合は、<code>Dispatcher.Invoke</code>メソッドを使う必要があります。次のセクションの例では、<code>Dispatcher.Invoke</code>メソッドを使っています。
        </p>
    </section>
    <section>
        <h2 id="11">二重起動を防止し、起動中のウィンドウをアクティブにする</h2>
        <p><code>Semaphore</code>を使って二重起動を防止し、<code>System.Runtime.Remoting.Channels.Ipc</code>名前空間のクラスを使って起動中のウィンドウと通信します。
        </p>
        <p><code>System.Runtime.Remoting.Channels.Ipc</code>名前空間のクラスを使うので、参照設定にSystem.Runtime.Remotingを追加する必要があります。</p>
        <pre><code><span class="keyword">using</span> System;
<span class="keyword">using</span> System.Runtime.Remoting;
<span class="keyword">using</span> System.Runtime.Remoting.Channels;
<span class="keyword">using</span> System.Runtime.Remoting.Channels.Ipc;
<span class="keyword">using</span> System.Threading;
<span class="keyword">using</span> System.Windows;

<span class="keyword">namespace</span> WpfApplication1
{
    <span class="keyword">public</span> <span class="keyword">partial</span> <span class="keyword">class</span> <span class="usertype">App</span> : <span class="usertype">Application</span>
    {
        <span class="keyword">const</span> <span class="keyword">string</span> ApplicationId = <span class="string">&quot;00000000-0000-0000-0000-000000000000&quot;</span>; <span class="comment">// 実際はUUIDなどが良い。</span>
        <em><span class="keyword">const</span> <span class="keyword">string</span> HandlerName = <span class="string">&quot;handler&quot;</span>;</em>

        [<span class="usertype">STAThread</span>]
        <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> Main(<span class="keyword">string</span>[] args)
        {
            <span class="keyword">bool</span> createdNew;
            <span class="keyword">using</span> (<span class="keyword">var</span> semaphore = <span class="keyword">new</span> <span class="usertype">Semaphore</span>(1, 1, ApplicationId, <span class="keyword">out</span> createdNew))
            {
                <span class="keyword">if</span> (createdNew)
                {
                    <em><span class="usertype">ChannelServices</span>.RegisterChannel(<span class="keyword">new</span> <span class="usertype">IpcServerChannel</span>(ApplicationId), <span class="keyword">true</span>);
                    <span class="usertype">RemotingServices</span>.Marshal(<span class="keyword">new</span> <span class="usertype">Handler</span>(), HandlerName, <span class="keyword">typeof</span>(<span class="usertype">Handler</span>));</em>

                    <span class="keyword">var</span> app = <span class="keyword">new</span> <span class="usertype">App</span>();
                    app.InitializeComponent();
                    app.Run();
                }
                <em><span class="keyword">else</span>
                {
                    <span class="usertype">ChannelServices</span>.RegisterChannel(<span class="keyword">new</span> <span class="usertype">IpcClientChannel</span>(), <span class="keyword">true</span>);
                    ((<span class="usertype">Handler</span>)<span class="usertype">Activator</span>.GetObject(<span class="keyword">typeof</span>(<span class="usertype">Handler</span>), <span class="string">&quot;ipc://&quot;</span> + ApplicationId + <span class="string">&quot;/&quot;</span> + HandlerName)).Handle();
                }</em>
            }
        }

        <em><span class="keyword">class</span> <span class="usertype">Handler</span> : <span class="usertype">MarshalByRefObject</span>
        {
            <span class="keyword">public</span> <span class="keyword">void</span> Handle()
            {
                Current.Dispatcher.Invoke(() =&gt; Current.MainWindow.Activate());
            }

            <span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">object</span> InitializeLifetimeService() =&gt; <span class="keyword">null</span>;
        }</em>
    }
}</code></pre>
    </section>
    <section>
        <h2 id="12">二重起動を防止し、起動中のウィンドウをアクティブにしてコマンドライン引数を渡す</h2>
        <p>App.xaml.csは以下のようにします。<code>ArgsReceived</code>という静的イベントを宣言し、二重起動を防止したとき、イベントが発生するようにしています。このとき、引数にコマンドライン引数を指定します。
        </p>
        <pre><code><span class="keyword">using</span> System;
<span class="keyword">using</span> System.Runtime.Remoting;
<span class="keyword">using</span> System.Runtime.Remoting.Channels;
<span class="keyword">using</span> System.Runtime.Remoting.Channels.Ipc;
<span class="keyword">using</span> System.Threading;
<span class="keyword">using</span> System.Windows;

<span class="keyword">namespace</span> WpfApplication1
{
    <span class="keyword">public</span> <span class="keyword">partial</span> <span class="keyword">class</span> <span class="usertype">App</span> : <span class="usertype">Application</span>
    {
        <span class="keyword">const</span> <span class="keyword">string</span> ApplicationId = <span class="string">&quot;00000000-0000-0000-0000-000000000000&quot;</span>; <span class="comment">// 実際はUUIDなどが良い。</span>
        <span class="keyword">const</span> <span class="keyword">string</span> HandlerName = <span class="string">&quot;handler&quot;</span>;

        <em><span class="keyword">public</span> <span class="keyword">delegate</span> <span class="keyword">void</span> <span class="usertype">ArgsReceivedEventHandler</span>(<span class="keyword">string</span>[] args);

        <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">event</span> <span class="usertype">ArgsReceivedEventHandler</span> ArgsReceived;</em>

        [<span class="usertype">STAThread</span>]
        <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> Main(<span class="keyword">string</span>[] args)
        {
            <span class="keyword">bool</span> createdNew;
            <span class="keyword">using</span> (<span class="keyword">var</span> semaphore = <span class="keyword">new</span> <span class="usertype">Semaphore</span>(1, 1, ApplicationId, <span class="keyword">out</span> createdNew))
            {
                <span class="keyword">if</span> (createdNew)
                {
                    <span class="usertype">ChannelServices</span>.RegisterChannel(<span class="keyword">new</span> <span class="usertype">IpcServerChannel</span>(ApplicationId), <span class="keyword">true</span>);
                    <span class="usertype">RemotingServices</span>.Marshal(<span class="keyword">new</span> <span class="usertype">Handler</span>(), HandlerName, <span class="keyword">typeof</span>(<span class="usertype">Handler</span>));

                    <span class="keyword">var</span> app = <span class="keyword">new</span> <span class="usertype">App</span>();
                    app.InitializeComponent();
                    app.Run();
                }
                <span class="keyword">else</span>
                {
                    <span class="usertype">ChannelServices</span>.RegisterChannel(<span class="keyword">new</span> <span class="usertype">IpcClientChannel</span>(), <span class="keyword">true</span>);
                    ((<span class="usertype">Handler</span>)<span class="usertype">Activator</span>.GetObject(<span class="keyword">typeof</span>(<span class="usertype">Handler</span>), <span class="string">&quot;ipc://&quot;</span> + ApplicationId + <span class="string">&quot;/&quot;</span> + HandlerName)).Handle(<em>args</em>);
                }
            }
        }

        <span class="keyword">class</span> <span class="usertype">Handler</span> : <span class="usertype">MarshalByRefObject</span>
        {
            <span class="keyword">public</span> <span class="keyword">void</span> Handle(<em><span class="keyword">string</span>[] args</em>)
            {
                <em><span class="keyword">if</span> (ArgsReceived != <span class="keyword">null</span>)
                    Current.Dispatcher.Invoke(ArgsReceived, (<span class="keyword">object</span>)args);</em>
            }

            <span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">object</span> InitializeLifetimeService() =&gt; <span class="keyword">null</span>;
        }
    }
}</code></pre>
        <p><code><span class="usertype">Handler</span></code>クラスの<code>Handle</code>メソッドで、<code>args</code>を<code><span class="keyword">object</span></code>にキャストしている所で<q>キャストが冗長です。</q>という警告が出ます。しかし、このキャストは必要です。キャストしないと、<code><span class="keyword">string</span>[]</code>型の<code>args</code>が<code><span class="keyword">string</span></code>型の可変長引数と判断され、例外が発生します。もしくは、<code><span class="keyword">new</span> <span class="keyword">object</span>[] { args }</code>のように記述すれば警告も例外も出ません。
        </p>
        <p>MainWindow.xaml.csは以下のようにします。<code>App</code>の<code>ArgsReceived</code>静的イベントに、渡されたコマンドライン引数を処理するイベントハンドラーを追加しています。イベントハンドラーの中でウィンドウをアクティブにし、またコマンドライン引数を処理しています。
        </p>
        <pre><code><span class="keyword">using</span> System.Windows;

<span class="keyword">namespace</span> WpfApplication1
{
    <span class="keyword">public</span> <span class="keyword">partial</span> <span class="keyword">class</span> <span class="usertype">MainWindow</span> : <span class="usertype">Window</span>
    {
        <span class="keyword">public</span> MainWindow()
        {
            InitializeComponent();

            <em><span class="usertype">App</span>.ArgsReceived += args =&gt;
            {
                Activate();

                <span class="keyword">foreach</span> (<span class="keyword">string</span> arg <span class="keyword">in</span> args)
                    <span class="usertype">MessageBox</span>.Show(arg);
            };</em>
        }
    }
}</code></pre>
    </section>
    <section>
        <h2 id="13">二重起動を防止し、起動中のウィンドウをアクティブにする（メモリマップトファイルを使う）</h2>
        <p>以下のようにします。ちゃんとした解説はそのうち書くかもしれません。</p>
        <p>コード中の<code>HandleInitialized</code>は独自に追加したイベントです。本来は<code>SourceInitialized</code>を使えばよいものです。</p>
        <pre><code class="C#">using System;
using System.IO;
using System.IO.MemoryMappedFiles;
using System.Runtime.InteropServices;
using System.Threading;
using System.Windows;

namespace DesktopBackgroundScribbler
{
    /// &lt;summary&gt;
    /// App.xaml の相互作用ロジック
    /// &lt;/summary&gt;
    public partial class App : Application
    {
        const string id = "{14482529-941C-4025-80F8-1836D76B064B}";
        const string memoryMappedFileName = id + ".dat";

        const int SW_RESTORE = 9;

        [DllImport("user32.dll", CharSet = CharSet.Auto)]
        static extern bool IsIconic(IntPtr hWnd);

        [DllImport("user32.dll", CharSet = CharSet.Auto)]
        static extern bool ShowWindowAsync(IntPtr hWnd, int nCmdShow);

        [DllImport("user32.dll", CharSet = CharSet.Auto)]
        static extern bool SetForegroundWindow(IntPtr hWnd);

        [STAThread]
        public static void Main()
        {
            using (var semaphore = new Semaphore(1, 1, id, out var createdNew))
            {
                if (!createdNew)
                {
                    TryActivateExistingWindow();
                    return;
                }

                var app = new App();
                app.InitializeComponent();

                var mainWindow = new MainWindow();

                using (var mmf = MemoryMappedFile.CreateNew(memoryMappedFileName, 8))
                {
                    mainWindow.HandleInitialized += (sender, e) =>
                    {
                        var windowHandle = mainWindow.Handle.ToInt64();

                        using (var stream = mmf.CreateViewStream())
                        {
                            var binaryWriter = new BinaryWriter(stream);
                            binaryWriter.Write(windowHandle);
                        }
                    };

                    app.Run(mainWindow);
                }
            }
        }

        private static void TryActivateExistingWindow()
        {
            var count = 0;
            do
            {
                try
                {
                    using (var mmf = MemoryMappedFile.OpenExisting(memoryMappedFileName))
                    using (var stream = mmf.CreateViewStream(0, 8, MemoryMappedFileAccess.Read))
                    {
                        var binaryReader = new BinaryReader(stream);
                        var windowHandle = binaryReader.ReadInt64();
                        if (windowHandle > 0)
                        {
                            ActivateExistingWindow(windowHandle);
                            return;
                        }
                    }
                }
                catch (FileNotFoundException) { }

                Thread.Sleep(1000);
            } while (++count &lt; 10);
        }

        private static void ActivateExistingWindow(long windowHandle)
        {
            var hWnd = new IntPtr(windowHandle);

            if (IsIconic(hWnd))
            {
                ShowWindowAsync(hWnd, SW_RESTORE);
            }

            SetForegroundWindow(hWnd);
        }
    }
}</code></pre>
    </section>
</body>

</html>