<!DOCTYPE html>
<html lang="ja">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width">
    <title>WPF による開発覚え書き</title>
    <link rel="stylesheet" type="text/css" href="Style.css">
    <link rel="icon" type="image/png" href="Icon.png">
    <link rel="start" href="index.html" title="トップページ">
    <style>
        .keyword,
        .xamlsign {
            color: #0000FF
        }

        .comment {
            color: #008000
        }

        .usertype {
            color: #2B91AF
        }

        .string {
            color: #A31515
        }

        .xamlname {
            color: #A31515
        }

        .xamlattr {
            color: #FF0000
        }
    </style>
    <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/10.7.2/styles/vs.min.css">
    <script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/10.7.2/highlight.min.js" defer></script>
    <script>addEventListener('DOMContentLoaded', () => hljs.highlightAll())</script>
    <meta name="author" content="Itaru">
</head>

<body>
    <header>
        <a href="/"><img src="Logo.svg" width="400" height="80" alt="トップページへ"></a>
        <table>
            <tr>
                <th>最終更新</th>
                <td>2021年6月1日 20時36分</td>
            </tr>
        </table>
    </header>
    <h1>WPF による開発覚え書き</h1>
    <p>Visual C# 2010 Express や、Visual Studio Community 2015、Visual Studio Community 2017 で、WPF アプリケーションを開発した際の覚え書きです。未だ WPF には詳しくないので、ここに書いてあることは大間違いかもしれません。</p>
    <ol>
        <li>
            Visual C# 2010 Express 時代
            <ul>
                <li><a href="#1">コマンドライン引数を取得する（<code>Startup</code>イベントを使う）</a></li>
                <li><a href="#2">二重起動を防止する（<code>Mutex</code>を使う）</a></li>
                <li><a href="#3">任意のコレクションオブジェクトの内容を<code>ListBox</code>や<code>ListView</code>で表示する</a></li>
                <li><a href="#4"><code>ListView</code>の各列に指定したプロパティを表示する</a></li>
                <li><a href="#5"><code>ListView</code>の各列の幅を自動的に最適にする</a></li>
                <li><a href="#6">アニメーションの開始/一時停止/再開/停止</a></li>
                <li><a href="#7"><code>ListBox</code>の項目のドラッグによる並べ替え</a></li>
            </ul>
        </li>
        <li>
            Visual Studio Community 2015 時代
            <ul>
                <li><a href="#8">コマンドライン引数を取得する（<code>Main</code>メソッドを使う）</a></li>
                <li><a href="#9">二重起動を防止する（<code>Semaphore</code>を使う）</a></li>
                <li><a href="#10">アプリケーション間の通信</a></li>
                <li><a href="#11">二重起動を防止し、起動済みのウィンドウをアクティブにする</a></li>
                <li><a href="#12">二重起動を防止し、起動済みのウィンドウをアクティブにしてコマンドライン引数を渡す</a></li>
            </ul>
        </li>
        <li>
            Visual Studio Community 2017 時代
            <ul>
                <li><a href="#13">二重起動を防止し、起動済みのウィンドウをアクティブにする（メモリマップトファイルを使う）</a></li>
            </ul>
        </li>
        <li>
            Visual Studio 2019 時代（.NET 5.0 時代）
            <ul>
                <li><a href="#14">null 許容参照型を使う</a></li>
                <li><a href="#15"><code>Main</code> メソッドを明示的に実装する</a></li>
                <li><a href="#16"><code>Console.WriteLine()</code> の値を表示する</a></li>
            </ul>
        </li>
    </ol>
    <section>
        <h2 id="1">コマンドライン引数を取得する（<code>Startup</code>イベントを使う）</h2>
        <p>Visual C# 2010 Express で WPF アプリケーション プロジェクトを作成すると、App.xaml、App.xaml.cs、MainWindow.xaml、MainWindow.xaml.cs の4つのファイルが生成されます。このうちの App.xaml の <code>Application</code> 要素から <code>StartupUri</code> 属性を削除し、<code>Startup</code> 属性にイベントハンドラーとなるメソッドの名前を指定します。</p>
        <pre><code><span class="xamlsign">&lt;</span><span class="xamlname">Application</span> <span class="xamlattr">x</span>:<span class="xamlattr">Class</span><span class="xamlsign">="WpfApplication1.App"</span>
             <span class="xamlattr">xmlns</span><span class="xamlsign">="http://schemas.microsoft.com/winfx/2006/xaml/presentation"</span>
             <span class="xamlattr">xmlns</span><span class="xamlsign">:</span><span class="xamlattr">x</span><span class="xamlsign">="http://schemas.microsoft.com/winfx/2006/xaml"</span>
             <span class="xamlattr">Startup</span><span class="xamlsign">="Application_Startup"&gt;</span>
    <span class="xamlsign">&lt;</span><span class="xamlname">Application.Resources</span><span class="xamlsign">&gt;</span>

    <span class="xamlsign">&lt;/</span><span class="xamlname">Application.Resources</span><span class="xamlsign">&gt;</span>
<span class="xamlsign">&lt;/</span><span class="xamlname">Application</span><span class="xamlsign">&gt;</span></code></pre>
        <p>App.xaml.csは次のようにします。イベントハンドラーに渡される<code>StartupEventArgs</code>オブジェクトの<code>Args</code>プロパティーがコマンドライン引数です。</p>
        <pre><code><span class="keyword">using</span> System.Windows;

<span class="keyword">namespace</span> WpfApplication1
{
    <span class="keyword">public</span> <span class="keyword">partial</span> <span class="keyword">class</span> <span class="usertype">App</span> : <span class="usertype">Application</span>
    {
        <span class="keyword">private</span> <span class="keyword">void</span> Application_Startup(<span class="keyword">object</span> sender, <span class="usertype">StartupEventArgs</span> e)
        {
            <span class="keyword">foreach</span> (<span class="keyword">string</span> arg <span class="keyword">in</span> e.Args)
                <span class="usertype">MessageBox</span>.Show(arg);

            <span class="comment">// ウィンドウを表示。</span>
            <span class="usertype">MainWindow</span> mainWindow = <span class="keyword">new</span> <span class="usertype">MainWindow</span>(); <span class="comment">// 13行目</span>
            mainWindow.Show();                        <span class="comment">// 14行目</span>
        }
    }
}</code></pre>
        <p>App.xamlから<code>StartupUri</code>属性を削除したので、13、14行目を書かないとウィンドウは表示されません。</p>
    </section>
    <section>
        <h2 id="2">二重起動を防止する（<code>Mutex</code>を使う）</h2>
        <p><code>System.Threading.Mutex</code>を使います。<code>Mutex</code>のコンストラクターで、UUIDなど、アプリケーションを一意に識別するための文字列を渡します。</p>
        <pre><code><span class="keyword">using</span> System.Threading;
<span class="keyword">using</span> System.Windows;

<span class="keyword">namespace</span> WpfApplication1
{
    <span class="keyword">public</span> <span class="keyword">partial</span> <span class="keyword">class</span> <span class="usertype">App</span> : <span class="usertype">Application</span>
    {
        <span class="keyword">private</span> <span class="keyword">static</span> <span class="usertype">Mutex</span> mutex = <span class="keyword">new</span> <span class="usertype">Mutex</span>(<span class="keyword">false</span>, <span class="string">"WpfApplication1"</span>); <span class="comment">// 実際はUUIDなどがよい。</span>

        <span class="keyword">private</span> <span class="keyword">void</span> Application_Startup(<span class="keyword">object</span> sender, <span class="usertype">StartupEventArgs</span> e)
        {
            <span class="keyword">if</span> (mutex.WaitOne(0, <span class="keyword">false</span>))
            {
                <span class="usertype">MessageBox</span>.Show(<span class="string">"先に起動しているインスタンスはありません。"</span>);

                <span class="comment">// ウィンドウを表示</span>
                <span class="usertype">MainWindow</span> mainWindow = <span class="keyword">new</span> <span class="usertype">MainWindow</span>();
                mainWindow.Show();
            }
            <span class="keyword">else</span>
            {
                <span class="usertype">MessageBox</span>.Show(<span class="string">"先に起動しているインスタンスがあります。"</span>);
                Shutdown(); <span class="comment">// 終了する。</span>
            }
        }
    }
}</code></pre>
        <p>注意点として、生成した<code>Mutex</code>オブジェクトがガーベッジコレクションによって消滅すると、2つ目以降のインスタンスが起動できるようになってしまいます。そこで上記の例では、<code>Mutex</code>オブジェクトをstaticフィールドとすることで、消滅しないようにしています。</p>
    </section>
    <section>
        <h2 id="3">任意のコレクションオブジェクトの内容を<code>ListBox</code>や<code>ListView</code>で表示する</h2>
        <p>次のように、<code>ListBox</code>や<code>ListView</code>の<code>ItemsSource</code>プロパティーにコレクションオブジェクトを指定するだけです。コレクションオブジェクトは、<code>System.Collections.IEnumerable</code>を実装している必要があります。</p>
        <pre><code><span class="keyword">using</span> System.Collections.Generic;
<span class="keyword">using</span> System.ComponentModel;
<span class="keyword">using</span> System.Windows;
<span class="keyword">using</span> System.Windows.Data;

<span class="keyword">namespace</span> WpfApplication1
{
    <span class="keyword">public</span> <span class="keyword">partial</span> <span class="keyword">class</span> <span class="usertype">App</span> : <span class="usertype">Application</span>
    {
        <span class="usertype">List</span>&lt;<span class="keyword">string</span>&gt; list = <span class="keyword">new</span> <span class="usertype">List</span>&lt;<span class="keyword">string</span>&gt;();
        <span class="usertype">ICollectionView</span> collectionView;

        <span class="keyword">private</span> <span class="keyword">void</span> Application_Startup(<span class="keyword">object</span> sender, <span class="usertype">StartupEventArgs</span> e)
        {
            list.Add(<span class="string">"リートルード"</span>);
            list.Add(<span class="string">"Hello, World!"</span>);
            collectionView = <span class="usertype">CollectionViewSource</span>.GetDefaultView(list);

            <span class="usertype">MainWindow</span> mainWindow = <span class="keyword">new</span> <span class="usertype">MainWindow</span>();

            mainWindow.listBox1.ItemsSource = list;

            mainWindow.Show();

            list.Add(<span class="string">"Coming Era..."</span>);
            collectionView.Refresh(); <span class="comment">// 26行目</span>
        }
    }
}</code></pre>
        <p>ただし、コレクションオブジェクトの更新を<code>ListBox</code>や<code>ListView</code>の表示に反映させるには、26行目のように<code>ICollectionView.Refresh</code>メソッドを呼び出す必要があります。あるいは、ObservableCollectionクラスを使えば、Refresh()は不要です。</p>
    </section>
    <section>
        <h2 id="4"><code>ListView</code>の各列に指定したプロパティを表示する</h2>
        <p>次のように、<code>GridViewColumn</code>要素の<code>DisplayMemberBinding</code>属性で、プロパティ名を指定します。</p>
        <pre><code><span class="xamlsign">&lt;</span><span class="xamlname">Window</span> <span class="xamlattr">x</span><span class="xamlsign">:</span><span class="xamlattr">Class</span><span class="xamlsign">="WpfApplication1.MainWindow"</span>
        <span class="xamlattr">xmlns</span><span class="xamlsign">="http://schemas.microsoft.com/winfx/2006/xaml/presentation"</span>
        <span class="xamlattr">xmlns</span><span class="xamlsign">:</span><span class="xamlattr">x</span><span class="xamlsign">="http://schemas.microsoft.com/winfx/2006/xaml"</span>
        <span class="xamlattr">Title</span><span class="xamlsign">="MainWindow"</span> <span class="xamlattr">Width</span><span class="xamlsign">="400"</span> <span class="xamlattr">Height</span><span class="xamlsign">="300"&gt;</span>
    <span class="xamlsign">&lt;</span><span class="xamlname">Grid</span><span class="xamlsign">&gt;</span>
        <span class="xamlsign">&lt;</span><span class="xamlname">ListView</span> <span class="xamlattr">Name</span><span class="xamlsign">="listView1"&gt;</span>
            <span class="xamlsign">&lt;</span><span class="xamlname">ListView.View</span><span class="xamlsign">&gt;</span>
                <span class="xamlsign">&lt;</span><span class="xamlname">GridView</span><span class="xamlsign">&gt;</span>
                    <span class="xamlsign">&lt;</span><span class="xamlname">GridViewColumn</span> <span class="xamlattr">DisplayMemberBinding</span><span class="xamlsign">="{</span><span class="xamlname">Binding</span> <span class="xamlattr">Name</span><span class="xamlsign">}"/&gt;</span>
                    <span class="xamlsign">&lt;</span><span class="xamlname">GridViewColumn</span> <span class="xamlattr">DisplayMemberBinding</span><span class="xamlsign">="{</span><span class="xamlname">Binding</span> <span class="xamlattr">Level</span><span class="xamlsign">}"/&gt;</span>
                <span class="xamlsign">&lt;/</span><span class="xamlname">GridView</span><span class="xamlsign">&gt;</span>
            <span class="xamlsign">&lt;/</span><span class="xamlname">ListView.View</span><span class="xamlsign">&gt;</span>
        <span class="xamlsign">&lt;/</span><span class="xamlname">ListView</span><span class="xamlsign">&gt;</span>
    <span class="xamlsign">&lt;/</span><span class="xamlname">Grid</span><span class="xamlsign">&gt;</span>
<span class="xamlsign">&lt;/</span><span class="xamlname">Window</span><span class="xamlsign">&gt;</span></code></pre>
        <p>この例では、App.xaml.csは次のようにしています。<code>User</code>というクラスがあり、<code>ListView</code>の各行に表示されるのは、<code>List</code>に格納された<code>User</code>のインスタンスです。</p>
        <pre><code><span class="keyword">using</span> System.Collections.Generic;
<span class="keyword">using</span> System.ComponentModel;
<span class="keyword">using</span> System.Windows;
<span class="keyword">using</span> System.Windows.Data;

<span class="keyword">namespace</span> WpfApplication1
{
    <span class="keyword">public</span> <span class="keyword">partial</span> <span class="keyword">class</span> <span class="usertype">App</span> : <span class="usertype">Application</span>
    {
        <span class="usertype">List</span>&lt;<span class="usertype">User</span>&gt; list = <span class="keyword">new</span> <span class="usertype">List</span>&lt;<span class="usertype">User</span>&gt;();
        <span class="usertype">ICollectionView</span> collectionView;

        <span class="keyword">private</span> <span class="keyword">void</span> Application_Startup(<span class="keyword">object</span> sender, <span class="usertype">StartupEventArgs</span> e)
        {
            list.Add(<span class="keyword">new</span> <span class="usertype">User</span>(<span class="string">"Abc"</span>, 5));
            list.Add(<span class="keyword">new</span> <span class="usertype">User</span>(<span class="string">"Defg"</span>, 4));
            collectionView = <span class="usertype">CollectionViewSource</span>.GetDefaultView(list);

            <span class="usertype">MainWindow</span> mainWindow = <span class="keyword">new</span> <span class="usertype">MainWindow</span>();

            mainWindow.listView1.ItemsSource = list;

            mainWindow.Show();

            list.Add(<span class="keyword">new</span> <span class="usertype">User</span>(<span class="string">"Hijkl"</span>, 7));
            collectionView.Refresh();
        }
    }

    <span class="keyword">class</span> <span class="usertype">User</span>
    {
        <span class="keyword">public</span> <span class="keyword">string</span> Name { <span class="keyword">get</span>; <span class="keyword">set</span>; }
        <span class="keyword">public</span> <span class="keyword">int</span> Level { <span class="keyword">get</span>; <span class="keyword">set</span>; }

        <span class="keyword">public</span> User(<span class="keyword">string</span> name, <span class="keyword">int</span> level)
        {
            Name = name;
            Level = level;
        }
    }
}</code></pre>
    </section>
    <section>
        <h2 id="5"><code>ListView</code>の各列の幅を自動的に最適にする</h2>
        <pre><code><span class="keyword">foreach</span> (<span class="usertype">GridViewColumn</span> column <span class="keyword">in</span> (listView1.View <span class="keyword">as</span> <span class="usertype">GridView</span>).Columns)
{
    column.Width = 0;
    column.Width = <span class="keyword">double</span>.NaN;
}</code></pre>
        <p>このようにすれば、列ヘッダーの境界をダブルクリックしたときのように、列幅が最適な状態になります。何度も行うなら、その<code>GridViewColumn</code>をフィールドに保持しておいてもいいでしょう。</p>
    </section>
    <section>
        <h2 id="6">アニメーションの開始/一時停止/再開/停止</h2>
        <p>次のようなXAMLがあるとします。</p>
        <pre><code><span class="xamlsign">&lt;</span><span class="xamlname">Window</span> <span class="xamlattr">x</span><span class="xamlsign">:</span><span class="xamlattr">Class</span><span class="xamlsign">="WpfApplication1.MainWindow"</span>
        <span class="xamlattr">xmlns</span><span class="xamlsign">="http://schemas.microsoft.com/winfx/2006/xaml/presentation"</span>
        <span class="xamlattr">xmlns</span><span class="xamlsign">:</span><span class="xamlattr">x</span><span class="xamlsign">="http://schemas.microsoft.com/winfx/2006/xaml"</span>
        <span class="xamlattr">Title</span><span class="xamlsign">="MainWindow"</span> <span class="xamlattr">Width</span><span class="xamlsign">="400"</span> <span class="xamlattr">Height</span><span class="xamlsign">="300"&gt;</span>
    <span class="xamlsign">&lt;</span><span class="xamlname">StackPanel</span><span class="xamlsign">&gt;</span>
        <span class="xamlsign">&lt;</span><span class="xamlname">Rectangle</span> <span class="xamlattr">Name</span><span class="xamlsign">="rectangle1"</span> <span class="xamlattr">Width</span><span class="xamlsign">="0"</span> <span class="xamlattr">Height</span><span class="xamlsign">="20"</span> <span class="xamlattr">Fill</span><span class="xamlsign">="Blue"/&gt;</span>
        <span class="xamlsign">&lt;</span><span class="xamlname">Button</span> <span class="xamlattr">Content</span><span class="xamlsign">="Start"</span> <span class="xamlattr">Click</span><span class="xamlsign">="StartButton_Click"/&gt;</span>
        <span class="xamlsign">&lt;</span><span class="xamlname">Button</span> <span class="xamlattr">Content</span><span class="xamlsign">="Pause/Resume"</span> <span class="xamlattr">Click</span><span class="xamlsign">="PauseResumeButton_Click"</span> <span class="xamlattr">IsEnabled</span><span class="xamlsign">="False"</span> <span class="xamlattr">Name</span><span class="xamlsign">="pauseResumeButton"/&gt;</span>
        <span class="xamlsign">&lt;</span><span class="xamlname">Button</span> <span class="xamlattr">Content</span><span class="xamlsign">="Stop"</span> <span class="xamlattr">Click</span><span class="xamlsign">="StopButton_Click"</span> <span class="xamlattr">IsEnabled</span><span class="xamlsign">="False"</span> <span class="xamlattr">Name</span><span class="xamlsign">="stopButton"/&gt;</span>
        <span class="comment">&lt;!-- 起動直後はPause/ResumeボタンとStopボタンは無効状態としている。--&gt;</span>
    <span class="xamlsign">&lt;/</span><span class="xamlname">StackPanel</span><span class="xamlsign">&gt;</span>
<span class="xamlsign">&lt;/</span><span class="xamlname">Window</span><span class="xamlsign">&gt;</span></code></pre>
        <p>Startボタンを押すとアニメーション開始、Pause/Resumeボタンを押すと一時停止、同じボタンをもう一度押すと再開、Stopボタンを押すと停止、という挙動をC#コードで実現するには、MainWindow.xaml.csを次のようにします。</p>
        <pre><code><span class="keyword">using</span> System;
<span class="keyword">using</span> System.Windows;
<span class="keyword">using</span> System.Windows.Media.Animation;
<span class="keyword">using</span> System.Windows.Shapes;

<span class="keyword">namespace</span> WpfApplication1
{
    <span class="keyword">public</span> <span class="keyword">partial</span> <span class="keyword">class</span> <span class="usertype">MainWindow</span> : <span class="usertype">Window</span>
    {
        <span class="usertype">Storyboard</span> storyboard = <span class="keyword">new</span> <span class="usertype">Storyboard</span>();

        <span class="keyword">public</span> MainWindow()
        {
            InitializeComponent();

            <span class="usertype">DoubleAnimation</span> animation = <span class="keyword">new</span> <span class="usertype">DoubleAnimation</span>();

            <span class="usertype">Storyboard</span>.SetTarget(animation, rectangle1);
            <span class="usertype">Storyboard</span>.SetTargetProperty(animation, <span class="keyword">new</span> <span class="usertype">PropertyPath</span>(<span class="usertype">Rectangle</span>.WidthProperty));
            animation.To = 400; <span class="comment">// アニメーション後の値を指定。</span>
            animation.Duration = <span class="usertype">TimeSpan</span>.FromSeconds(10); <span class="comment">// アニメーションする時間を指定。</span>
            storyboard.Children.Add(animation);
        }

        <span class="keyword">private</span> <span class="keyword">void</span> StartButton_Click(<span class="keyword">object</span> sender, <span class="usertype">RoutedEventArgs</span> e)
        {
            storyboard.Begin();

            <span class="keyword">if</span> (!pauseResumeButton.IsEnabled)
            {
                <span class="comment">// 起動直後は無効状態としていたPause/ResumeボタンとStopボタンを有効にする。</span>
                pauseResumeButton.IsEnabled = <span class="keyword">true</span>;
                stopButton.IsEnabled = <span class="keyword">true</span>;
            }
        }

        <span class="keyword">private</span> <span class="keyword">void</span> PauseResumeButton_Click(<span class="keyword">object</span> sender, <span class="usertype">RoutedEventArgs</span> e)
        {
            <span class="keyword">if</span> (storyboard.GetIsPaused())
                storyboard.Resume();
            <span class="keyword">else</span>
                storyboard.Pause();
        }

        <span class="keyword">private</span> <span class="keyword">void</span> StopButton_Click(<span class="keyword">object</span> sender, <span class="usertype">RoutedEventArgs</span> e)
        {
            storyboard.Stop();
        }
    }
}</code></pre>
    </section>
    <section>
        <h2 id="7"><code>ListBox</code>の項目のドラッグによる並べ替え</h2>
        <p>MainWindow.xamlは次のようにします。</p>
        <pre><code><span class="xamlsign">&lt;</span><span class="xamlname">Window</span> <span class="xamlattr">x</span><span class="xamlsign">:</span><span class="xamlattr">Class</span><span class="xamlsign">="ListBoxExTest.MainWindow"</span>
        <span class="xamlattr">xmlns</span><span class="xamlsign">="http://schemas.microsoft.com/winfx/2006/xaml/presentation"</span>
        <span class="xamlattr">xmlns</span><span class="xamlsign">:</span><span class="xamlattr">x</span><span class="xamlsign">="http://schemas.microsoft.com/winfx/2006/xaml"</span>
        <span class="xamlattr">Title</span><span class="xamlsign">="MainWindow"</span> <span class="xamlattr">Height</span><span class="xamlsign">="350"</span> <span class="xamlattr">Width</span><span class="xamlsign">="525"&gt;</span>
    <span class="xamlsign">&lt;</span><span class="xamlname">Grid</span><span class="xamlsign">&gt;</span>
        <span class="xamlsign">&lt;</span><span class="xamlname">ListBox</span> <span class="xamlattr">Name</span><span class="xamlsign">="listBox1"&gt;</span>
            <span class="xamlsign">&lt;</span><span class="xamlname">ListBoxItem</span> <span class="xamlattr">AllowDrop</span><span class="xamlsign">="True"</span> <span class="xamlattr">MouseMove</span><span class="xamlsign">="ListBoxItem_MouseMove"</span> <span class="xamlattr">DragEnter</span><span class="xamlsign">="ListBoxItem_DragEnter"&gt;</span><span class="xamlname">色は匂えど</span><span class="xamlsign">&lt;/</span><span class="xamlname">ListBoxItem</span><span class="xamlsign">&gt;</span>
            <span class="xamlsign">&lt;</span><span class="xamlname">ListBoxItem</span> <span class="xamlattr">AllowDrop</span><span class="xamlsign">="True"</span> <span class="xamlattr">MouseMove</span><span class="xamlsign">="ListBoxItem_MouseMove"</span> <span class="xamlattr">DragEnter</span><span class="xamlsign">="ListBoxItem_DragEnter"&gt;</span><span class="xamlname">散りぬるを</span><span class="xamlsign">&lt;/</span><span class="xamlname">ListBoxItem</span><span class="xamlsign">&gt;</span>
            <span class="xamlsign">&lt;</span><span class="xamlname">ListBoxItem</span> <span class="xamlattr">AllowDrop</span><span class="xamlsign">="True"</span> <span class="xamlattr">MouseMove</span><span class="xamlsign">="ListBoxItem_MouseMove"</span> <span class="xamlattr">DragEnter</span><span class="xamlsign">="ListBoxItem_DragEnter"&gt;</span><span class="xamlname">我が世誰ぞ</span><span class="xamlsign">&lt;/</span><span class="xamlname">ListBoxItem</span><span class="xamlsign">&gt;</span>
            <span class="xamlsign">&lt;</span><span class="xamlname">ListBoxItem</span> <span class="xamlattr">AllowDrop</span><span class="xamlsign">="True"</span> <span class="xamlattr">MouseMove</span><span class="xamlsign">="ListBoxItem_MouseMove"</span> <span class="xamlattr">DragEnter</span><span class="xamlsign">="ListBoxItem_DragEnter"&gt;</span><span class="xamlname">常ならん</span><span class="xamlsign">&lt;/</span><span class="xamlname">ListBoxItem</span><span class="xamlsign">&gt;</span>
        <span class="xamlsign">&lt;/</span><span class="xamlname">ListBox</span><span class="xamlsign">&gt;</span>
    <span class="xamlsign">&lt;/</span><span class="xamlname">Grid</span><span class="xamlsign">&gt;</span>
<span class="xamlsign">&lt;/</span><span class="xamlname">Window</span><span class="xamlsign">&gt;</span></code></pre>
        <p>まず<code>ListBoxItem</code>の<code>AllowDrop</code>プロパティをOnにします。そして、<code>MouseMove</code>と<code>DragEnter</code>という2つのイベントにイベントハンドラーを指定します。</p>
        <p>MainWindow.xaml.csは次のようにします。</p>
        <pre><code><span class="keyword">using</span> System.Windows;
<span class="keyword">using</span> System.Windows.Controls;
<span class="keyword">using</span> System.Windows.Input;

<span class="keyword">namespace</span> ListBoxExTest
{
    <span class="keyword">public</span> <span class="keyword">partial</span> <span class="keyword">class</span> <span class="usertype">MainWindow</span> : <span class="usertype">Window</span>
    {
        <span class="keyword">public</span> MainWindow()
        {
            InitializeComponent();
        }

        <span class="keyword">private</span> <span class="keyword">void</span> ListBoxItem_MouseMove(<span class="keyword">object</span> sender, <span class="usertype">MouseEventArgs</span> e)
        {
            <span class="keyword">if</span> (e.LeftButton == <span class="usertype">MouseButtonState</span>.Pressed)
                <span class="usertype">DragDrop</span>.DoDragDrop(sender <span class="keyword">as</span> <span class="usertype">ListBoxItem</span>, sender, <span class="usertype">DragDropEffects</span>.Move);
        }

        <span class="keyword">private</span> <span class="keyword">void</span> ListBoxItem_DragEnter(<span class="keyword">object</span> sender, <span class="usertype">DragEventArgs</span> e)
        {
            <span class="usertype">ListBoxItem</span> source = e.Data.GetData(<span class="keyword">typeof</span>(<span class="usertype">ListBoxItem</span>)) <span class="keyword">as</span> <span class="usertype">ListBoxItem</span>;

            <span class="usertype">ItemCollection</span> items = listBox1.Items;

            <span class="keyword">int</span> index = items.IndexOf(sender <span class="keyword">as</span> <span class="usertype">ListBoxItem</span>);
            items.Remove(source);
            items.Insert(index, source);
        }
    }
}</code></pre>
        <p>ドラッグの開始は、<code>MouseMove</code>のイベントハンドラーの中で、<code>DragDrop</code>クラスの静的メソッドである<code>DoDragDrop()</code>によって行います。このとき、並べ替える<code>ListBoxItem</code>を引数に指定しておきます。</p>
        <p>並べ替えは、<code>DragEnter</code>のイベントハンドラーの中で行います。第2引数の<code>DragEventArgs</code>オブジェクトの<code>Data</code>プロパティーの<code>GetData</code>メソッドで、先に指定した<code>ListBoxItem</code>が取得できます。</p>
    </section>
    <section>
        <h2 id="8">コマンドライン引数を取得する（<code>Main</code>メソッドを使う）</h2>
        <p>Visual Studio Community 2015でWPF アプリケーション プロジェクトを作成すると、App.xaml、App.xaml.cs、MainWindow.xaml、MainWindow.xaml.csの4つのファイルが生成されます。このうち、App.xamlのプロパティで、ビルド アクションをApplicationDefinitionからPageに変更します。</p>
        <p>ビルド アクションをPageにすると、<code>Main</code>メソッドが自動で実装されなくなり、以下のようにApp.xaml.csに明示的に定義する必要があります。このとき、<code>Main</code>メソッドの仮引数からコマンドライン引数を取得できます。</p>
        <pre><code><span class="keyword">using</span> System;
<span class="keyword">using</span> System.Windows;

<span class="keyword">namespace</span> WpfApplication1
{
    <span class="keyword">public</span> <span class="keyword">partial</span> <span class="keyword">class</span> <span class="usertype">App</span> : <span class="usertype">Application</span>
    {
        <em><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">string</span>[] Args { <span class="keyword">get</span>; <span class="keyword">set</span>; }</em>

        [<span class="usertype">STAThread</span>]
        <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> Main(<em><span class="keyword">string</span>[] args</em>)
        {
            <em>Args = args;</em>

            <span class="keyword">var</span> app = <span class="keyword">new</span> <span class="usertype">App</span>();       <span class="comment">// 15行目</span>
            app.InitializeComponent(); <span class="comment">// 16行目</span>
            app.Run();                 <span class="comment">// 17行目</span>
        }
    }
}</code></pre>
        <p>このコードでは、コマンドライン引数をほかの場所からも参照できるようにするため、<code>App</code>に<code>Args</code>という静的プロパティを定義し、そこに代入しています。また、<code>Main</code>メソッドを明示的に実装しているため、15～17行目を記述しなければアプリケーションは開始しません。</p>
        <dl>
            <dt>参考</dt>
            <dd><a href="http://www.atmarkit.co.jp/ait/articles/1511/04/news027.html">WPF：Mainメソッドを書き変えるには？［C#／VB］</a></dd>
        </dl>
    </section>
    <section>
        <h2 id="9">二重起動を防止する（<code>Semaphore</code>を使う）</h2>
        <p><code>System.Threading.Semaphore</code>を使う方法です。<code>Semaphore</code>のコンストラクターで、UUIDなど、アプリケーションを一意に識別するための文字列を渡します。</p>
        <pre><code><span class="keyword">using</span> System;
<span class="keyword">using</span> System.Threading;
<span class="keyword">using</span> System.Windows;

<span class="keyword">namespace</span> WpfApplication1
{
    <span class="keyword">public</span> <span class="keyword">partial</span> <span class="keyword">class</span> <span class="usertype">App</span> : <span class="usertype">Application</span>
    {
        <em><span class="keyword">const</span> <span class="keyword">string</span> ApplicationId = <span class="string">&quot;00000000-0000-0000-0000-000000000000&quot;</span>;</em> <span class="comment">// 実際はUUIDなどが良い。</span>

        [<span class="usertype">STAThread</span>]
        <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> Main(<span class="keyword">string</span>[] args)
        {
<em>            <span class="keyword">bool</span> createdNew;
            <span class="keyword">using</span> (<span class="keyword">var</span> semaphore = <span class="keyword">new</span> <span class="usertype">Semaphore</span>(1, 1, ApplicationId, <span class="keyword">out</span> createdNew))
            {
                <span class="keyword">if</span> (createdNew)
                {</em>
                    <span class="keyword">var</span> app = <span class="keyword">new</span> <span class="usertype">App</span>();
                    app.InitializeComponent();
                    app.Run();
<em>                }
            }</em>
        }
    }
}</code></pre>
        <dl>
            <dt>参考</dt>
            <dd><a href="http://www.atmarkit.co.jp/ait/articles/1511/18/news028.html">WPF：多重起動を禁止するには？［C#／VB］</a></dd>
        </dl>
    </section>
    <section>
        <h2 id="10">アプリケーション間の通信</h2>
        <p>まず、参照設定にSystem.Runtime.Remotingを追加する必要があります。</p>
        <p>次に、<code>System.MarshalByRefObject</code>を継承したクラスを作成します。</p>
        <pre><code><span class="keyword">using</span> System;

<span class="keyword">namespace</span> WpfApplication1
{
    <span class="keyword">class</span> <span class="usertype">Handler</span> : <span class="usertype">MarshalByRefObject</span>
    {
        <span class="keyword">public</span> <span class="keyword">void</span> Handle()
        {
            <span class="comment">// 通信が行われたときの処理を記述する。</span>
        }

        <span class="comment">// 通信可能な状態を保ち続けるためのオーバーライド。</span>
        <span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">object</span> InitializeLifetimeService() => <span class="keyword">null</span>;
    }
}</code></pre>
        <p><code>MarshalByRefObject</code>を継承した<code>Handler</code>クラスでは、<code>InitializeLifetimeService</code>というメソッドをオーバーライドしています。これは、時間経過によって、通信できなくなる状態に自動的になってしまうのを防ぐためです。</p>
        <p>通信のサーバー側は、次のように記述します。<code>IpcServerChannel</code>のコンストラクターでは、UUIDなど、アプリケーションを一意に識別するための文字列を渡します。<code>RemotingServices.Marshal</code>メソッドの第2引数では、<code>MarshalByRefObject</code>オブジェクトを識別するための文字列を指定します。</p>
        <pre><code><span class="keyword">const</span> <span class="keyword">string</span> ApplicationId = <span class="string">"00000000-0000-0000-0000-000000000000"</span>; <span class="comment">// 実際はUUIDなどが良い。</span>
<span class="keyword">const</span> <span class="keyword">string</span> HandlerName = <span class="string">"handler"</span>;

<span class="usertype">ChannelServices</span>.RegisterChannel(<span class="keyword">new</span><span class="usertype">IpcServerChannel</span>(ApplicationId), <span class="keyword">true</span>);
<span class="usertype">RemotingServices</span>.Marshal(<span class="keyword">new</span> <span class="usertype">Handler</span>(), HandlerName, <span class="keyword">typeof</span>(<span class="usertype">Handler</span>));</code></pre>
        <p>通信のクライアント側は、次のように記述します。</p>
        <pre><code><span class="usertype">ChannelServices</span>.RegisterChannel(<span class="keyword">new</span> <span class="usertype">IpcClientChannel</span>(), <span class="keyword">true</span>);
((<span class="usertype">Handler</span>)<span class="usertype">Activator</span>.GetObject(<span class="keyword">typeof</span>(<span class="usertype">Handler</span>), <span class="string">"ipc://"</span> + ApplicationId + <span class="string">"/"</span> + HandlerName)).Handle();</code></pre>
        <p>ただし、ユーザーインターフェースに変更を加えるなど、別のスレッドに関係する処理を行う場合は、<code>Dispatcher.Invoke</code>メソッドを使う必要があります。次のセクションの例では、<code>Dispatcher.Invoke</code>メソッドを使っています。</p>
    </section>
    <section>
        <h2 id="11">二重起動を防止し、起動済みのウィンドウをアクティブにする</h2>
        <p><code>Semaphore</code>を使って二重起動を防止し、<code>System.Runtime.Remoting.Channels.Ipc</code>名前空間のクラスを使って起動済みのウィンドウと通信します。</p>
        <p><code>System.Runtime.Remoting.Channels.Ipc</code>名前空間のクラスを使うので、参照設定にSystem.Runtime.Remotingを追加する必要があります。</p>
        <pre><code><span class="keyword">using</span> System;
<span class="keyword">using</span> System.Runtime.Remoting;
<span class="keyword">using</span> System.Runtime.Remoting.Channels;
<span class="keyword">using</span> System.Runtime.Remoting.Channels.Ipc;
<span class="keyword">using</span> System.Threading;
<span class="keyword">using</span> System.Windows;

<span class="keyword">namespace</span> WpfApplication1
{
    <span class="keyword">public</span> <span class="keyword">partial</span> <span class="keyword">class</span> <span class="usertype">App</span> : <span class="usertype">Application</span>
    {
        <span class="keyword">const</span> <span class="keyword">string</span> ApplicationId = <span class="string">&quot;00000000-0000-0000-0000-000000000000&quot;</span>; <span class="comment">// 実際はUUIDなどが良い。</span>
        <em><span class="keyword">const</span> <span class="keyword">string</span> HandlerName = <span class="string">&quot;handler&quot;</span>;</em>

        [<span class="usertype">STAThread</span>]
        <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> Main(<span class="keyword">string</span>[] args)
        {
            <span class="keyword">bool</span> createdNew;
            <span class="keyword">using</span> (<span class="keyword">var</span> semaphore = <span class="keyword">new</span> <span class="usertype">Semaphore</span>(1, 1, ApplicationId, <span class="keyword">out</span> createdNew))
            {
                <span class="keyword">if</span> (createdNew)
                {
<em>                    <span class="usertype">ChannelServices</span>.RegisterChannel(<span class="keyword">new</span> <span class="usertype">IpcServerChannel</span>(ApplicationId), <span class="keyword">true</span>);
                    <span class="usertype">RemotingServices</span>.Marshal(<span class="keyword">new</span> <span class="usertype">Handler</span>(), HandlerName, <span class="keyword">typeof</span>(<span class="usertype">Handler</span>));</em>

                    <span class="keyword">var</span> app = <span class="keyword">new</span> <span class="usertype">App</span>();
                    app.InitializeComponent();
                    app.Run();
                }
<em>                <span class="keyword">else</span>
                {
                    <span class="usertype">ChannelServices</span>.RegisterChannel(<span class="keyword">new</span> <span class="usertype">IpcClientChannel</span>(), <span class="keyword">true</span>);
                    ((<span class="usertype">Handler</span>)<span class="usertype">Activator</span>.GetObject(<span class="keyword">typeof</span>(<span class="usertype">Handler</span>), <span class="string">&quot;ipc://&quot;</span> + ApplicationId + <span class="string">&quot;/&quot;</span> + HandlerName)).Handle();
                }</em>
            }
        }

<em>        <span class="keyword">class</span> <span class="usertype">Handler</span> : <span class="usertype">MarshalByRefObject</span>
        {
            <span class="keyword">public</span> <span class="keyword">void</span> Handle()
            {
                Current.Dispatcher.Invoke(() =&gt; Current.MainWindow.Activate());
            }

            <span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">object</span> InitializeLifetimeService() =&gt; <span class="keyword">null</span>;
        }</em>
    }
}</code></pre>
    </section>
    <section>
        <h2 id="12">二重起動を防止し、起動済みのウィンドウをアクティブにしてコマンドライン引数を渡す</h2>
        <p>App.xaml.csは以下のようにします。<code>ArgsReceived</code>という静的イベントを宣言し、二重起動を防止したとき、イベントが発生するようにしています。このとき、引数にコマンドライン引数を指定します。</p>
        <pre><code><span class="keyword">using</span> System;
<span class="keyword">using</span> System.Runtime.Remoting;
<span class="keyword">using</span> System.Runtime.Remoting.Channels;
<span class="keyword">using</span> System.Runtime.Remoting.Channels.Ipc;
<span class="keyword">using</span> System.Threading;
<span class="keyword">using</span> System.Windows;

<span class="keyword">namespace</span> WpfApplication1
{
    <span class="keyword">public</span> <span class="keyword">partial</span> <span class="keyword">class</span> <span class="usertype">App</span> : <span class="usertype">Application</span>
    {
        <span class="keyword">const</span> <span class="keyword">string</span> ApplicationId = <span class="string">&quot;00000000-0000-0000-0000-000000000000&quot;</span>; <span class="comment">// 実際はUUIDなどが良い。</span>
        <span class="keyword">const</span> <span class="keyword">string</span> HandlerName = <span class="string">&quot;handler&quot;</span>;

<em>        <span class="keyword">public</span> <span class="keyword">delegate</span> <span class="keyword">void</span> <span class="usertype">ArgsReceivedEventHandler</span>(<span class="keyword">string</span>[] args);

        <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">event</span> <span class="usertype">ArgsReceivedEventHandler</span> ArgsReceived;</em>

        [<span class="usertype">STAThread</span>]
        <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> Main(<span class="keyword">string</span>[] args)
        {
            <span class="keyword">bool</span> createdNew;
            <span class="keyword">using</span> (<span class="keyword">var</span> semaphore = <span class="keyword">new</span> <span class="usertype">Semaphore</span>(1, 1, ApplicationId, <span class="keyword">out</span> createdNew))
            {
                <span class="keyword">if</span> (createdNew)
                {
                    <span class="usertype">ChannelServices</span>.RegisterChannel(<span class="keyword">new</span> <span class="usertype">IpcServerChannel</span>(ApplicationId), <span class="keyword">true</span>);
                    <span class="usertype">RemotingServices</span>.Marshal(<span class="keyword">new</span> <span class="usertype">Handler</span>(), HandlerName, <span class="keyword">typeof</span>(<span class="usertype">Handler</span>));

                    <span class="keyword">var</span> app = <span class="keyword">new</span> <span class="usertype">App</span>();
                    app.InitializeComponent();
                    app.Run();
                }
                <span class="keyword">else</span>
                {
                    <span class="usertype">ChannelServices</span>.RegisterChannel(<span class="keyword">new</span> <span class="usertype">IpcClientChannel</span>(), <span class="keyword">true</span>);
                    ((<span class="usertype">Handler</span>)<span class="usertype">Activator</span>.GetObject(<span class="keyword">typeof</span>(<span class="usertype">Handler</span>), <span class="string">&quot;ipc://&quot;</span> + ApplicationId + <span class="string">&quot;/&quot;</span> + HandlerName)).Handle(<em>args</em>);
                }
            }
        }

        <span class="keyword">class</span> <span class="usertype">Handler</span> : <span class="usertype">MarshalByRefObject</span>
        {
            <span class="keyword">public</span> <span class="keyword">void</span> Handle(<em><span class="keyword">string</span>[] args</em>)
            {
<em>                <span class="keyword">if</span> (ArgsReceived != <span class="keyword">null</span>)
                    Current.Dispatcher.Invoke(ArgsReceived, (<span class="keyword">object</span>)args);</em>
            }

            <span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">object</span> InitializeLifetimeService() =&gt; <span class="keyword">null</span>;
        }
    }
}</code></pre>
        <p><code><span class="usertype">Handler</span></code>クラスの<code>Handle</code>メソッドで、<code>args</code>を<code><span class="keyword">object</span></code>にキャストしている所で<q>キャストが冗長です。</q>という警告が出ます。しかし、このキャストは必要です。キャストしないと、<code><span class="keyword">string</span>[]</code>型の<code>args</code>が<code><span class="keyword">string</span></code>型の可変長引数と判断され、例外が発生します。もしくは、<code><span class="keyword">new</span> <span class="keyword">object</span>[] { args }</code>のように記述すれば警告も例外も出ません。</p>
        <p>MainWindow.xaml.csは以下のようにします。<code>App</code>の<code>ArgsReceived</code>静的イベントに、渡されたコマンドライン引数を処理するイベントハンドラーを追加しています。イベントハンドラーの中でウィンドウをアクティブにし、またコマンドライン引数を処理しています。</p>
        <pre><code><span class="keyword">using</span> System.Windows;

<span class="keyword">namespace</span> WpfApplication1
{
    <span class="keyword">public</span> <span class="keyword">partial</span> <span class="keyword">class</span> <span class="usertype">MainWindow</span> : <span class="usertype">Window</span>
    {
        <span class="keyword">public</span> MainWindow()
        {
            InitializeComponent();

<em>            <span class="usertype">App</span>.ArgsReceived += args =&gt;
            {
                Activate();

                <span class="keyword">foreach</span> (<span class="keyword">string</span> arg <span class="keyword">in</span> args)
                    <span class="usertype">MessageBox</span>.Show(arg);
            };</em>
        }
    }
}</code></pre>
    </section>
    <section>
        <h2 id="13">二重起動を防止し、起動済みのウィンドウをアクティブにする（メモリマップトファイルを使う）</h2>
        <p>まずは <code>Main</code> メソッドを明示的に定義するようにします。そのために、<code>App.xaml</code> のビルド アクションを <code>Page</code> に変更します。</p>
        <p>また、<code>App.xaml</code> から <code>StartupUri</code> 属性を削除します。これで、表示処理を明示的に実行するまで、メインウィンドウは表示されません。</p>
        <pre><code class="xml">&lt;Application x:Class="WpfApp1.App"
            xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
            xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
            xmlns:local="clr-namespace:WpfApp1"&gt;
    &lt;Application.Resources&gt;

    &lt;/Application.Resources&gt;
&lt;/Application&gt;</code></pre>
        <p>次に、<code>MainWindow</code> に、ウィンドウハンドルを公開するプロパティを定義します。このプロパティには、<code>SourceInitialized</code> イベントで値を設定します。<code>SourceInitialized</code> イベントは、ウィンドウハンドルを取得できるようになる、最も早いタイミングのイベントです。</p>
        <pre><code class="C#">using System;
using System.Windows;
using System.Windows.Interop;

namespace WpfApp1
{
    public partial class MainWindow : Window
    {
        <em>public IntPtr Handle { get; private set; }</em>

        public MainWindow()
        {
            InitializeComponent();
        }

        protected override void OnSourceInitialized(EventArgs e)
        {
            <em>Handle = new WindowInteropHelper(this).Handle;</em>

            base.OnSourceInitialized(e);
        }
    }
}</code></pre>
        <p>そして、<code>App.xaml.cs</code> の <code>Main</code> メソッドを記述します。<code>Semaphore</code> で二重起動かどうかを判定し、二重起動であれば、メモリマップトファイルから、起動済みウィンドウのウィンドウハンドルを読み込みます。</p>
        <p>起動済みウィンドウをアクティブにするには、Windows API の <code>SetForegroundWindow</code> 関数を使います。この関数にウィンドウハンドルを渡します。また、ウィンドウが最小化していた場合は元のサイズに戻すため、<code>IsIconic</code> 関数と <code>ShowWindowAsync</code> 関数も使っています。</p>
        <p>なお、ごく短い時間ですが、「<code>Semaphore</code> によって二重起動は防止できているが、まだウィンドウハンドルは書き込まれていない」というタイミングが存在します。そのため、<code>TryActivateExistingWindow</code> メソッド（起動済みウィンドウのアクティブ化を試みるメソッド）では、メモリマップトファイルから読み込んだ値が <kbd>0</kbd> だった場合、10回まで再試行するようにしています。</p>
        <pre><code class="C#">using System;
using System.IO;
using System.IO.MemoryMappedFiles;
using System.Runtime.InteropServices;
using System.Threading;
using System.Windows;

namespace WpfApp1
{
    public partial class App : Application
    {
        const string applicationId = "00000000-0000-0000-0000-000000000000"; // 実際はUUIDなどが良い。
        const string memoryMappedFileName = applicationId + ".dat";

        const int SW_RESTORE = 9;

        [DllImport("user32.dll")]
        static extern bool IsIconic(IntPtr hWnd);

        [DllImport("user32.dll")]
        static extern bool ShowWindowAsync(IntPtr hWnd, int nCmdShow);

        [DllImport("user32.dll")]
        static extern bool SetForegroundWindow(IntPtr hWnd);

        [STAThread]
        public static void Main(string[] args)
        {
            using (var semaphore = new Semaphore(1, 1, applicationId, out var createdNew))
            {
                if (!createdNew)
                {
                    TryActivateExistingWindow();
                    return;
                }

                var app = new App();
                app.InitializeComponent();

                var mainWindow = new MainWindow();

                using (var mmf = <em>MemoryMappedFile.CreateNew(memoryMappedFileName, 8)</em>)
                {
                    mainWindow.SourceInitialized += (sender, e) =>
                    {
                        var windowHandle = mainWindow.Handle.ToInt64();

                        using (var stream = mmf.CreateViewStream())
                        {
                            var binaryWriter = new BinaryWriter(stream);
                            binaryWriter.Write(windowHandle);
                        }
                    };

                    app.Run(mainWindow);
                }
            }
        }

        private static void TryActivateExistingWindow()
        {
            var count = 0;
            do
            {
                try
                {
                    using (var mmf = <em>MemoryMappedFile.OpenExisting(memoryMappedFileName)</em>)
                    using (var stream = mmf.CreateViewStream(0, 8, MemoryMappedFileAccess.Read))
                    {
                        var binaryReader = new BinaryReader(stream);
                        var windowHandle = binaryReader.ReadInt64();
                        if (windowHandle > 0)
                        {
                            ActivateExistingWindow(windowHandle);
                            return;
                        }
                    }
                }
                catch (FileNotFoundException) { }

                Thread.Sleep(1000);
            } while (++count &lt; 10);
        }

        private static void ActivateExistingWindow(long windowHandle)
        {
            var hWnd = new IntPtr(windowHandle);

            if (IsIconic(hWnd))
            {
                ShowWindowAsync(hWnd, SW_RESTORE);
            }

            <em>SetForegroundWindow(hWnd);</em>
        }
    }
}</code></pre>
    </section>
    <section>
        <h2 id="14">null 許容参照型を使う</h2>
        <p>今後の .NET 開発では、.NET Framework ではなく .NET 5.0 およびその後継を検討するべきです。ここでも .NET 5.0 を使っています。</p>
        <p>Visual Studio 2019 で作成したプロジェクトで、C# 8.0 で追加された null 許容参照型を使うには、<code>.csproj</code> を直接編集します。下記のように、<code>&lt;Nullable&gt;enable&lt;/Nullable&gt;</code>を記述すると、null 許容参照型が有効になります。</p>
        <pre><code class="xml">&lt;Project Sdk="Microsoft.NET.Sdk"&gt;

    &lt;PropertyGroup&gt;
    &lt;OutputType&gt;WinExe&lt;/OutputType&gt;
    &lt;TargetFramework&gt;net5.0-windows&lt;/TargetFramework&gt;
    &lt;UseWPF&gt;true&lt;/UseWPF&gt;
    <em>&lt;Nullable&gt;enable&lt;/Nullable&gt;</em>
  &lt;/PropertyGroup&gt;

&lt;/Project&gt;</code></pre>
    </section>
    <section>
        <h2 id="15"><code>Main</code> メソッドを明示的に実装する</h2>
        <p>.NET 5.0 の WPF アプリケーションでは、<code>App.xaml</code> というファイルは、ビルド アクションが自動的に ApplicationDefinition になります。そのため、Visual Studio のプロパティ ウィンドウで、<code>App.xaml</code> のビルド アクションを変更するとエラーが発生します。</p>
        <p><code>Main</code> メソッドを明示的に実装するには、まずこの挙動を変更します。それには、<code>.csproj</code> を直接編集して、<code>&lt;EnableDefaultApplicationDefinition&gt;false&lt;/EnableDefaultApplicationDefinition&gt;</code>を記述します。</p>
        <pre><code code="xml">&lt;Project Sdk="Microsoft.NET.Sdk"&gt;

  &lt;PropertyGroup&gt;
    &lt;OutputType&gt;WinExe&lt;/OutputType&gt;
    &lt;TargetFramework&gt;net5.0-windows&lt;/TargetFramework&gt;
    &lt;UseWPF&gt;true&lt;/UseWPF&gt;
    &lt;Nullable&gt;enable&lt;/Nullable&gt;
    <em>&lt;EnableDefaultApplicationDefinition&gt;false&lt;/EnableDefaultApplicationDefinition&gt;</em>
  &lt;/PropertyGroup&gt;

&lt;/Project&gt;</code></pre>
        <p>これで、<code>Main</code> メソッドが自動生成されなくなるので、<code>App.xaml.cs</code> に、<code>Main</code> メソッドを明示的に実装します。コマンドライン引数を受け取ることもできます。</p>
        <pre><code class="C#">public partial class App : Application
{
<em>    [STAThread]
    public static void Main(string[] args)
    {
        var app = new App();
        app.InitializeComponent();
        app.Run();
    }</em>
}</code></pre>
    </section>
    <section>
        <h2 id="16"><code>Console.WriteLine()</code> の値を表示する</h2>
        <p>Visual Studio 2019 で、新たに WPF アプリケーションを作成し、<code>Console.WriteLine()</code> を記述しても、コンソールに表示はされません。.NET Framework の場合、プロジェクトのプロパティで「出力の種類」を「コンソール アプリケーション」にすると表示されるようになりますが、.NET 5.0 の場合は、単にこの操作を行っても、自動的に「WPF アプリケーション」に戻ります。</p>
        <p>あえて「コンソール アプリケーション」にするならば、<code>.csproj</code>に<code>&lt;DisableWinExeOutputInference&gt;true&lt;/DisableWinExeOutputInference&gt;</code>を記述します。これで、自動的に「WPF アプリケーション」に戻ることはなくなります。あとは、<code>OutputType</code>を<code>Exe</code>に変更するか、プロジェクトのプロパティの「出力の種類」を「コンソール アプリケーション」にします。</p>
        <pre><code>&lt;Project Sdk="Microsoft.NET.Sdk"&gt;

  &lt;PropertyGroup&gt;
    <em>&lt;OutputType&gt;Exe&lt;/OutputType&gt;</em>
    &lt;TargetFramework&gt;net5.0-windows&lt;/TargetFramework&gt;
    &lt;UseWPF&gt;true&lt;/UseWPF&gt;
    <em>&lt;DisableWinExeOutputInference&gt;true&lt;/DisableWinExeOutputInference&gt;</em>
  &lt;/PropertyGroup&gt;

&lt;/Project&gt;</code></pre>
        <p>なお、このように設定すると、実行時にコンソール ウィンドウが表示されるようになります。プログラムがデスクトップ アプリケーションであり、実行時にコンソール ウィンドウが表示されるのが不格好だと感じるならば、このように設定するべきではありません。</p>
        <dl>
            <dt>参考</dt>
            <dd><a href="https://docs.microsoft.com/ja-jp/dotnet/core/compatibility/sdk/5.0/automatically-infer-winexe-output-type">OutputType set to WinExe for WPF and WinForms apps</a></dd>
        </dl>
    </section>
</body>

</html>